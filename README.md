# Angular-Change-Detection
- Slides for Angular change detection
- 变更检测的基本任务是获取程序的内部状态，并使其以某种方式对用户界面可见
- 这种状态可以是任何类型的对象，数组，主要类型或者说 原始类型 只是任何类型的JavaScript数据结构，都可以算作状态
- 这种状态可能最终成为用户界面中的段落，表单，链接或按钮，特别是在Web上，它是文档对象模型（DOM）。所以基本上我们将数据结构作为输入并生成DOM输出以将其显示给用户。我们将此过程称为渲染
- 我们如何弄清楚模型中的变化，以及我们需要更新DOM的位置
- 访问DOM树总是很昂贵，因此我们不仅需要找出需要更新的位置，而且我们还希望尽可能地减少开销。
- 面的组件只显示两个属性，并提供了一种方法，可以在单击模板中的按钮时更改它们。单击此特定按钮的那一刻是应用程序状态发生更改的时刻，因为它会更改组件的属性。那是我们想要更新视图的那一刻
- 基本上每当执行一些异步操作时，我们的应用程序状态可能已经改变。这时就是angular被通知出现变更需要检测的时刻
- 在Angular的源代码中，有一个名为ApplicationRef的东西，它监听NgZones onTurnDone事件。每当触发此事件时，它都会执行tick（）函数，该函数基本上执行变更检测
- 让我们假设在组件树的某个地方触发了一个事件，可能已经点击了一个按钮。接下来发生什么？我们刚刚了解到zone执行给定的处理程序并在onTurnDown完成时通知Angular，最终导致Angular执行更改检测。
- 因为单向数据流比循环更可预测。我们总是知道我们在视图中使用的数据来自何处，因为它只能来自其组件。
- 另一个有趣的观察是一次通过后变化检测变得稳定。这意味着，如果我们的某个组件在更改检测期间第一次运行后导致任何其他副作用，Angular将抛出错误。
- Observables会触发我们可以订阅的事件，以便对它们作出反应
- Component 的 changeDetection 设定为 ChangeDetectionStrategy.OnPush，如果有使用 setTimeout 时，就必须配合 markForCheck() 的方法来更新 View 的显示

- Hello 大家好, 我是Tom 很荣幸今天能被大漠老师邀请到这里就angular这个框架说出一些我自己的见地和理解
因为看到大漠老师也在为了推进国内angular的普及下了很大的功夫 我希望也能在这个方面尽我自己的一份力
正如标题所言 我们依托这个平台来给 angular做助推器 然后我今天会说的是angular的变更检测这个方面 
如果能够深入理解这个方面就好像是你弄懂了javascript的词法作用域 闭包这些类似的概念一样 
能避免一些开发时候之前遇见过或者以后可能会的bug 
- 对啦我也简单介绍下我自己， 我从angular4开始全面用angular做开发,
也是一个nodejs开发者，我在微信群和qq群里的头像分别是这两个，
我有空的时候会经常在群里水，当然有问题也可以@我， 只要我看到我会的肯定会帮你看看,好我们现在开始
- 在我们理解变更检测之前 我们先要理解在我们运行环境（javascript）下什么是状态的以及状态的变化
状态在我们的代码中以数据的形式展现 可以是对象 数组 和 原祖类型（number string）等，数据也分为两种类型
一种是值类型string number boolean null undefined 一种则是引用类型 array object function类型，
变更检测的基本任务是获取程序的内部状态，并使其以某种方式展示给用户界面 这就是从宏观上变更检测的概念
这种状态可能最终成为用户界面中的段落，表单，链接或按钮，特别是在Web上，它是文档对象模型DOM
所以基本上我们将数据结构作为输入并生成DOM输出以将其显示给用户。那么当我们的检测发生在运行时，
我们如何弄清楚模型中的变化，以及我们需要更新DOM的位置就很关键了
访问DOM树总是很昂贵，因此我们不仅需要找出需要更新的位置，而且我们还希望尽可能地减少开销
- 总体而言对于变更检测有几种方案，比如在ajax出现以前，通过事件发送一个http请求到后端，后端重新利用jsp也好
 模版引擎也好 重新渲染前端页面，或者说用的是react 虚拟dom的方案 
 比较虚拟dom和更新后dom的区别后将更新的部分渲染到真实的dom上，亦或者是初代的js框架backbone extjs,
 这些框架提供了将UI代码与模型分离的体系结构，但它们仍然保留了两者之间的同步。
 我们可以在发生更改时获得某种事件，但我们也有责任确定要重新呈现的内容以及如何进行更改
 - 那回到angular中，我们的angular变更检测是如何进行的呢？
首先我们要知道在angular中我们何时发生改变，比如在这里我们通过点击button按钮 
触发click事件调用changeName方法将 firstname和lastname的属性修改为awesome 和 angular，
这个过程中我们的状态发生了变更
或者在另一个例子中，我们在Oninit钩子里利用调用http get请求从文件或者后端获取数据 
并异步地将获得的数据赋值给component中person属性， 这样的过程同样也产生了状态变更
- 在知晓了angular如何会产生变更检测之后，了解是谁通知了angular出现了状态变更呢？这里我不会深究这个话题
这里涉及到了angular更底层的zone.js，展开来说会单独展开一个章节，这里我们先从整体上理解这个问题，
zonejs原本是dart里面的一个特性 angular继承了这个特性并命名为ngzone， ngzone像是一个观测者观测每一个
angular的状态变更行为的变化从行为开始到行为结束，而从全局的角度来说 ， 
applicationref 相当于是angular应用这个类会在他的构造器内订阅ngzone的onturndone事件，
并在订阅后又zone运行整个angular应用程序内的所有变更探测器的接口，
而这些结构是和angular的树形结构一样绑定在每个组件上用来监听每一个组件的
- 我们先逃离zonejs这个更加趋紧核心的概念来理解变更检测，就像我刚刚说的那样，
 变更检测的核心概念就是在于angular每一个组件都拥有自己的变更检测器，变更检测树与组件树平行，并且这这个树是一个有向图形式的树，
 树内的数据会从上到下流动
 - 为什么要用单向数据流从上而下呢？因为单向数据流比循环数据流更容易预测。我们总是知道我们在视图中使用的数据来自何处，因为它只能来自其组件。
 另一个好处是通过变化检测后组件树变得稳定。这意味着，如果我们的某个组件在更改检测期间第一次运行后导致任何其他副作用，Angular将抛出错误，
 而这个错误就是经典的ExpressionChangedAfterItHasBeenCheckedError，我们会在后面说这个经典问题
- 这里可能有人会有疑问说为什么angular为什么是单向数据流，父子组件之间不是可以通过@Input和@output进行交互吗，
或者组件间也可以通过service进行交互。
 
 
 