# Angular-Change-Detection
- Slides for Angular change detection
- 变更检测的基本任务是获取程序的内部状态，并使其以某种方式对用户界面可见
- 这种状态可以是任何类型的对象，数组，主要类型或者说 原始类型 只是任何类型的JavaScript数据结构，都可以算作状态
- 这种状态可能最终成为用户界面中的段落，表单，链接或按钮，特别是在Web上，它是文档对象模型（DOM）。所以基本上我们将数据结构作为输入并生成DOM输出以将其显示给用户。我们将此过程称为渲染
- 我们如何弄清楚模型中的变化，以及我们需要更新DOM的位置
- 访问DOM树总是很昂贵，因此我们不仅需要找出需要更新的位置，而且我们还希望尽可能地减少开销。
- 面的组件只显示两个属性，并提供了一种方法，可以在单击模板中的按钮时更改它们。单击此特定按钮的那一刻是应用程序状态发生更改的时刻，因为它会更改组件的属性。那是我们想要更新视图的那一刻
- 基本上每当执行一些异步操作时，我们的应用程序状态可能已经改变。这时就是angular被通知出现变更需要检测的时刻
- 在Angular的源代码中，有一个名为ApplicationRef的东西，它监听NgZones onTurnDone事件。每当触发此事件时，它都会执行tick（）函数，该函数基本上执行变更检测
- 让我们假设在组件树的某个地方触发了一个事件，可能已经点击了一个按钮。接下来发生什么？我们刚刚了解到zone执行给定的处理程序并在onTurnDown完成时通知Angular，最终导致Angular执行更改检测。
- 因为单向数据流比循环更可预测。我们总是知道我们在视图中使用的数据来自何处，因为它只能来自其组件。
- 另一个有趣的观察是一次通过后变化检测变得稳定。这意味着，如果我们的某个组件在更改检测期间第一次运行后导致任何其他副作用，Angular将抛出错误。
- Observables会触发我们可以订阅的事件，以便对它们作出反应
- Component 的 changeDetection 设定为 ChangeDetectionStrategy.OnPush，如果有使用 setTimeout 时，就必须配合 markForCheck() 的方法来更新 View 的显示

- Hello 大家好, 我是Tom 很荣幸今天能被大漠老师邀请到这里就angular这个框架说出一些我自己的见地和理解
因为看到大漠老师也在为了推进国内angular的普及下了很大的功夫 我希望也能在这个方面尽我自己的一份力
正如标题所言 我们依托这个平台来给 angular做助推器 然后我今天会说的是angular的变更检测这个方面 
如果能够深入理解这个方面就好像是你弄懂了javascript的词法作用域 闭包这些类似的概念一样 
能避免一些开发时候之前遇见过或者以后可能会的bug 
- 对啦我也简单介绍下我自己， 我从angular4开始全面用angular做开发,
也是一个nodejs开发者，我在微信群和qq群里的头像分别是这两个，
我有空的时候会经常在群里水，当然有问题也可以@我， 只要我看到我会的肯定会帮你看看,好我们现在开始
- 在我们理解变更检测之前 我们先要理解在我们运行环境（javascript）下什么是状态的以及状态的变化
状态在我们的代码中以数据的形式展现 可以是对象 数组 和 原祖类型（number string）等，数据也分为两种类型
一种是值类型string number boolean null undefined 一种则是引用类型 array object function类型，
变更检测的基本任务是获取程序的内部状态，并使其以某种方式展示给用户界面 这就是从宏观上变更检测的概念
这种状态可能最终成为用户界面中的段落，表单，链接或按钮，特别是在Web上，它是文档对象模型DOM
所以基本上我们将数据结构作为输入并生成DOM输出以将其显示给用户。那么当我们的检测发生在运行时，
我们如何弄清楚模型中的变化，以及我们需要更新DOM的位置就很关键了
访问DOM树总是很昂贵，因此我们不仅需要找出需要更新的位置，而且我们还希望尽可能地减少开销
- 总体而言对于变更检测有几种方案，比如在ajax出现以前，通过事件发送一个http请求到后端，后端重新利用jsp也好
 模版引擎也好 重新渲染前端页面，或者说用的是react 虚拟dom的方案 
 比较虚拟dom和更新后dom的区别后将更新的部分渲染到真实的dom上，亦或者是初代的js框架backbone extjs,
 这些框架提供了将UI代码与模型分离的体系结构，但它们仍然保留了两者之间的同步。
 我们可以在发生更改时获得某种事件，但我们也有责任确定要重新呈现的内容以及如何进行更改
 - 那回到angular中，我们的angular变更检测是如何进行的呢？
首先我们要知道在angular中我们何时发生改变，比如在这里我们通过点击button按钮 
触发click事件调用changeName方法将 firstname和lastname的属性修改为awesome 和 angular，
这个过程中我们的状态发生了变更
或者在另一个例子中，我们在Oninit钩子里利用调用http get请求从文件或者后端获取数据 
并异步地将获得的数据赋值给component中person属性， 这样的过程同样也产生了状态变更
- 在知晓了angular如何会产生变更检测之后，了解是谁通知了angular出现了状态变更呢？这里我不会深究这个话题
这里涉及到了angular更底层的zone.js，展开来说会单独展开一个章节，这里我们先从整体上理解这个问题，
zonejs原本是dart里面的一个特性 angular继承了这个特性并命名为ngzone， ngzone像是一个观测者观测每一个
angular的状态变更行为的变化从行为开始到行为结束，而从全局的角度来说 ， 
applicationref 相当于是angular应用这个类会在他的构造器内订阅ngzone的onturndone事件，
并在订阅后又zone运行整个angular应用程序内的所有变更探测器的接口，
而这些结构是和angular的树形结构一样绑定在每个组件上用来监听每一个组件的
- 我们先逃离zonejs这个更加趋紧核心的概念来理解变更检测，就像我刚刚说的那样，
 变更检测的核心概念就是在于angular每一个组件都拥有自己的变更检测器，变更检测树与组件树平行，并且这这个树是一个有向图形式的树，
 树内的数据会从上到下流动
 - 为什么要用单向数据流从上而下呢？因为单向数据流比循环数据流更容易预测。我们总是知道我们在视图中使用的数据来自何处，因为它只能来自其组件。
 另一个好处是通过变化检测后组件树变得稳定。这意味着，如果我们的某个组件在更改检测期间第一次运行后导致任何其他副作用，Angular将抛出错误，
- 这里可能有人会有疑问说为什么angular为什么是单向数据流，父子组件之间不是可以通过@Input和@output进行交互吗，
子组件也可以通过eventemitter修改父组件的属性，为什么说数据流是单向的呢？这里要明确一个angular的机制
Angular 分离了 更新程序 model 在前 和 同步model和view在后两个步骤，开发者只需要关注更新程序 model，同步 model 和 view 由 Angular 框架负责，
这个同步过程就是变更检测，说白了就是更新 view, 比如你给大漠的qq状态点赞，首先就是手指触发异步事件来更新程序 model，在组件里给 喜欢的属性1，
然后在下一个VM turn时 Angular 会自动更新视图中绑定的喜欢的值，这就是同步 model 和 view，点赞数就会从 0 变为 1
而输出绑定机制来更新父组件并不是在变更检测中执行的，它是在变更检测前的更新程序 model 阶段执行的，
所以，单向数据流的意思是指在变更检测期间属性绑定变更的架构。虽然说Angular 没有内置机制可以使得在变更检测期间去更新父组件，
然而可以通过组件间服务做到这一点。但是，又因为Angular 框架强迫单向数据流，
所以这么做会导致ExpressionChangedAfterItHasBeenCheckedError 错误，这是一个很经典的问题，我们之后再谈
- 好我们又聊到更有趣的话题，当我们说到树就不可避免的说到另一个话题，这个树是通过什么方式遍历的，是深度优先遍历还是广度优先遍历
我们结合代码来看
为什么当我们标记ngDoCheck钩子的时候会像是一个广度优先遍历呢 其实这就涉及到一个生命周期钩子调用的问题
ngDocheck听起来像是在执行本组件内的变更检测时会调用的钩子，其实不是，其实当angular在检查当前组件时，
它会调用子组件上的生命周期钩子，但是他会渲染当然的组件dom，这就是一个很有趣的事情了。
- 其实在变更检测的过程中，流程是这样的，我们在父组件内首先会更新子组件的input属性，然后我们会调用位于子组件内的ngDocheck生命周期钩子
然后我们更新当前组件的dom，最后我们把递归到子组件再一次执行我们的变更检测
- 其实在stackoverflow上有个很经典的问题，就是当组件在onPush策略下，即使组件的属性没有变更，为什么ngDocheck钩子仍然被调用了？
这就是因为即使你的Input属性没有变化，但是你的ngDocheck钩子其实是在父组件做变更检测的时候就已经被调用了
我们根据代码看。。。
- 那么变更检测流程是什么样的呢？首先会更新子组件的数据/属性绑定，然后更新Dom中的插值表达式，再更新利用动态组件创建的那些组件
关于动态组件不那么理解的可以去看大漠老师之前的视频讲解。最重要的是 变更检测不仅仅会触发生命周期钩子，甚至会在检查父组件的时候触发子组件的生命周期钩子
- 我们刚刚说了很多ngDoCheck的事情 那么ngDoCheck有什么奇技淫巧呢？ 那就是我们的markForCheck和OnPush策略，这个部分我们配合后面的内容一起说
- 其实单从外观上看我们每次变更检测都要从根组件一路检查到子组件，听起来这个过程肯定很费事，实际上angular在这一点很聪明的利用了虚拟机的关于运行时代码单态的优势，
，当我们的虚拟机在运行的时候如果它拿到的代码都是确定的单态的代码那他可以很快的处理渲染，而如果是多态的代码则会降低效率，angular利用了变更检测创造出来的代码在每一轮虚拟机执行中都是单态的
所以angular的变更检测效率是非常快的，所以我们不需要担心这些问题，angular早就帮我们处理好了这些问题
- 到目前为止可能我们对于变更检测的基本内容是已经说完了，我们接下来介绍一下对于变更检测的优化，毕竟可能我们可能不需要每一个组件都在变更检测里被检测，而angular默认的变更检测策略是自上而下全部检测的，
因为angular不知道有的组件没有被检测的需求 但是我们是知道的，这里就要介绍两个变更检测中的好帮手
一个是immutable不可变数据类型，一个是Observables 
- 首先需要理解什么是不可变什么是可变，不可变就是指我们的主要类型 也就是我们开头说的数值类型，而可变的数据类型就是我们的引用类型
在angular的默认变更检测策略下，即使你是可变的数据类型，比如你是一个对象有两个属性分别是name和email 而你在一次操作中将对象是name属性进行修改
那么angular其实是检测得到这次修改并且执行变更的，这是angular稳定的地方，毕竟如果你修改对象的数据而框架不予以变更 那就太糟糕了
- 那么怎么去创造不可变数据呢，拿同样的一个对象 我不去直接修改这个对象的属性而是重新给这个对象一个新的地址，就像代码显示的那样，
data2对象其实是一个新的对象拥有新的引用地址，那么对于data而言他就是一个不可变数据，如果要修改他 就必须修改他的引用地址，
- 那这个不可变数据有什么好处呢，其实他就是帮助变更检测的时候跳过某些组件的关键，当我们把@Input数据的属性设定为不可变的时候
我们就有了机会告诉angular，我们的这个组件的@Input属性可以不用默认检测策略，可以进行优化，比如配合OnPush策略
- 比如我们将左子组件树全部设置成onPush策略 这样只要左边子组件树的根组件@Input属性不发生变化，我们就可以不对左子组件树进行变更检测，这是一个很大的优化
- 我们在实际应用中使用Observable是很常见的，那如果我们的Input属性是一个Observable的数据怎么办呢，Observable也不是一个不可变数据，Observable配合OnPush策略应该怎么用呢？
- 比如这里我们有一个购物车的应用全部组件都使用了onpush策略，我们的input属性是一个Observable类型的数据，我们在Oninit钩子里订阅这个Observable，那么当我们的Observable发生变化时会发生什么呢
- 结果是应用的变更检测瘫痪了，没有任何变化被检测到，因为angular在onpush下不知道我们组件的属性发生了变化，也就不会触发变更检测
- 虽然angular不知道我们的应用出现了变化 但是我们开发者是清楚的，这时候我们利用组件的检测器引用，手动对组件设置变更需求，要求angular来检测该组件
方法是在组件类的构造器内应用该组件的检测器引用，并且在OnInit钩子中利用 markforcheck（）方法手动通知angular来检测该组件的属性
- 通过这样的方法 我们的组件树就可以正常运转了，当我们的observable变动触发，变更检测就会到这个子组件树进行变更检测，这样即使我们的Input属性是Observables也可以应用优化的变更检测策略了
- 而自主控制组件的变更检测器另一个应用领域就是当我们在Oninit钩子内是使用定时触发器时,我们结合代码来看
- 在angular4之前变更检测策略有6种，而现在只有default和onpush策略还保留在changeDetectionStragety中，剩下有两种可以用changeDetectorRef检测器实现，有兴趣的同学可以自己去探索一下
- 最后我来说说和变更检测有关的坑， 比如管道，如果我们在一个纯管道中对一个引用类型的数据进行转化，那这个纯管道会起不到应有的作用
- 而impure管道也就是非纯管道就是为了这种状况而存在的，他的作用就像是markforcheck，我们结合代码来看
- 遇到这样的状况你可以选择用impure管道 也可以选择将管道接受的值设置为immutable类型来处理 因为impure管道会在每次被调用时产生一个自己的实例
并且在每个检测周期内调用它的转化方法，会影响程序的效率，这部分涉及到管道的底层实现我们就不在此多提，我推荐将传递给管道的变量设置为不可变数据类型来运用纯管道
- 在每一次操作后,Angular会记下执行当前操作所需要的值并存放在组件视图(Angular Compiler会把每一个组件编译为对应的view class)的oldValues 属性里
 在所有组件的检查更新操作完成后,Angular并不是马上接着执行变更检测的操作，会把来自上一次检测循环的值与当前值比较
- 这是因为 setTimeout() 函数会让回调函数在下一个虚拟机循环中作为宏观任务被执行。如果使用 Promise.then 回调来包装，会在当前虚拟机循环中执行完同步代码后紧接着在当前循环继续执行回调函数
- 因为Angular实行的是从上到下的单向数据流，当父组件改变值已经和视图同步后不允许子组件去更新父组件的属性，这样确保在第一次检测循环后，整个组件树是稳定的  
                              
               
                       
 